# Docker & Kubernetes Deployment Workflow

Production-ready Docker and Kubernetes deployment pipelines with health checks, monitoring, and auto-scaling.

## What This Covers

- üê≥ **Docker image builds** and optimization
- ‚ò∏Ô∏è **Kubernetes deployment manifests**
- üîç **Health checks** and readiness probes
- üìä **Auto-scaling** with HPA
- üîí **Security hardening**
- üìà **Monitoring** with Prometheus

## File Structure

```
kubernetes/
‚îú‚îÄ‚îÄ deployment.yaml
‚îú‚îÄ‚îÄ service.yaml
‚îú‚îÄ‚îÄ hpa.yaml
‚îú‚îÄ‚îÄ configmap.yaml
‚îú‚îÄ‚îÄ secrets.yaml
‚îú‚îÄ‚îÄ ingress.yaml
‚îî‚îÄ‚îÄ network-policy.yaml

docker/
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ Dockerfile.production
‚îî‚îÄ‚îÄ docker-compose.yml
```

## Template 1: Production Dockerfile

`docker/Dockerfile.production`:
```dockerfile
# Use Node.js LTS as base
FROM node:18-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dev dependencies for build
RUN npm ci

# Install production dependencies only
COPY package*.json ./
RUN npm ci --only=production

# Build the app
COPY . .
RUN npm run build

# Production stage
FROM node:18-alpine

# Create non-root user for security
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001

WORKDIR /app

# Copy built application
COPY --from=builder --chown=nodejs:nodejs /app/dist ./dist
COPY --from=builder --chown=nodejs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nodejs:nodejs /app/package.json ./

# Switch to non-root user
USER nodejs

# Expose port
EXPOSE 3000

# Set environment
ENV NODE_ENV=production
ENV PORT=3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:3000/health || exit 1

# Start application
CMD ["node", "dist/server.js"]
```

## Template 2: Docker Compose for Development

`docker/docker-compose.yml`:
```yaml
version: '3.8'

services:
  # Application service
  app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=development
      - PORT=3000
    volumes:
      - ./:/app
      - /app/node_modules
    depends_on:
      - db
      - redis
      
    # Health check
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  # Database service
  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: appuser
      POSTGRES_PASSWORD: secret123
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"

  # Redis cache
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Nginx reverse proxy
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - app

volumes:
  postgres_data:
  redis_data:

networks:
  default:
    name: myapp-network
```

## Template 3: Kubernetes Deployment

`kubernetes/deployment.yaml`:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-deployment
  labels:
    app: myapp
    version: v1.0.0
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    metadata:
      labels:
        app: myapp
        version: v1.0.0
    spec:
      # Security Context
      securityContext:
        runAsNonRoot: true
        runAsUser: 1001
        fsGroup: 1001
      
      containers:
        - name: myapp
          image: myregistry/myapp:latest
          imagePullPolicy: Always
          ports:
            - containerPort: 3000
              protocol: TCP
          
          # Environment variables from ConfigMap
          envFrom:
            - configMapRef:
                name: myapp-config
            - secretRef:
                name: myapp-secrets
          
          # Resources
          resources:
            requests:
              memory: "256Mi"
              cpu: "250m"
            limits:
              memory: "512Mi"
              cpu: "500m"
          
          # Liveness probe
          lifecycle:
            preStop:
              exec:
                command: ["/bin/sh", "-c", "sleep 10"]
          
          livenessProbe:
            httpGet:
              path: /health
              port: 3000
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
            successThreshold: 1
            failureThreshold: 3
          
          # Readiness probe
          readinessProbe:
            httpGet:
              path: /ready
              port: 3000
            initialDelaySeconds: 15
            periodSeconds: 5
            timeoutSeconds: 3
            successThreshold: 1
            failureThreshold: 3
          
          # Volume mounts
          volumeMounts:
            - name: tmp-storage
              mountPath: /tmp

      # Init containers
      initContainers:
        - name: wait-for-db
          image: busybox:1.36
          command: ['sh', '-c', 'until nc -z db 5432; do echo waiting for db; sleep 2; done;']
      
      # Volumes
      volumes:
        - name: tmp-storage
          emptyDir: {}

      # Pod topology spread
      topologySpreadConstraints:
        - maxSkew: 1
          topologyKey: topology.kubernetes.io/zone
          whenUnsatisfiable: DoNotSchedule
          labelSelector:
            matchLabels:
              app: myapp
```

## Template 4: Kubernetes Service

`kubernetes/service.yaml`:
```yaml
apiVersion: v1
kind: Service
metadata:
  name: myapp-service
  labels:
    app: myapp
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "3000"
    prometheus.io/path: "/metrics"
spec:
  type: ClusterIP
  ports:
    - port: 80
      targetPort: 3000
      protocol: TCP
      name: http
  selector:
    app: myapp
```

## Template 5: Horizontal Pod Autoscaler

`kubernetes/hpa.yaml`:
```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: myapp-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: myapp-deployment
  minReplicas: 3
  maxReplicas: 10
  metrics:
    # CPU based scaling
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
    # Memory based scaling
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80
    # Custom metrics
    - type: Pods
      pods:
        metric:
          name: http_requests_per_second
        target:
          type: AverageValue
          averageValue: "100"
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
        - type: Percent
          value: 50
          periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
        - type: Percent
          value: 100
          periodSeconds: 15
        - type: Pods
          value: 4
          periodSeconds: 15
      selectPolicy: Max

# Scale the application based on load
```

## Template 6: ConfigMap & Secrets

`kubernetes/configmap.yaml`:
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: myapp-config
data:
  NODE_ENV: "production"
  APP_PORT: "3000"
  API_VERSION: "v1"
  LOG_LEVEL: "info"
  CACHE_TTL: "3600"
  FEATURE_FLAGS: "{\"new_checkout\":true,\"dark_mode\":true}"
  DATABASE_HOST: "db-service"
  REDIS_HOST: "redis-service"
```

`kubernetes/secrets.yaml`:
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: myapp-secrets
type: Opaque
stringData:
  DATABASE_URL: "postgresql://user:password@db:5432/myapp"
  JWT_SECRET: "your-super-secret-jwt-key-change-in-production"
  API_KEY: "your-api-key-here"
  REDIS_PASSWORD: "redis-password-here"
```

## Template 7: Kubernetes Ingress

`kubernetes/ingress.yaml`:
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: myapp-ingress
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/proxy-body-size: "50m"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "60"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:
  ingressClassName: nginx
  tls:
    - hosts:
        - api.example.com
        - www.example.com
      secretName: myapp-tls
  rules:
    - host: api.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: myapp-service
                port:
                  number: 80
```

## Template 8: Kubernetes Network Policy

`kubernetes/network-policy.yaml`:
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: myapp-network-policy
spec:
  podSelector:
    matchLabels:
      app: myapp
  policyTypes:
    - Ingress
    - Egress
  ingress:
    # Allow from ingresses
    - from:
        - namespaceSelector:
            matchLabels:
              name: ingress-nginx
      ports:
        - protocol: TCP
          port: 3000
    # Allow from same namespace
    - from:
        - podSelector: {}
      ports:
        - protocol: TCP
          port: 3000
  egress:
    # Allow DNS
    - to:
        - namespaceSelector:
            matchLabels:
              name: kube-system
      ports:
        - protocol: UDP
          port: 53
    # Allow DB
    - to:
        - podSelector:
            matchLabels:
              app: db
      ports:
        - protocol: TCP
          port: 5432
    # Allow Redis
    - to:
        - podSelector:
            matchLabels:
              app: redis
      ports:
        - protocol: TCP
          port: 6379
```

## Template 9: Prometheus Service Monitor

`kubernetes/service-monitor.yaml`:
```yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: myapp-monitor
  labels:
    release: prometheus
spec:
  selector:
    matchLabels:
      app: myapp
  endpoint:
    port: metrics
    interval: 30s
    path: /metrics
  namespaceSelector:
    matchNames:
      - default
```

## Deployment Commands

```bash
# Apply all manifests
kubectl apply -f kubernetes/

# Deploy with rollout
kubectl rollout deployment myapp-deployment

# Scale application
kubectl scale deployment myapp-deployment --replicas=5

# Check pod status
kubectl get pods -l app=myapp

# View pod logs
kubectl logs -l app=myapp -f

# Check HPA
kubectl get hpa

# Delete deployment
kubectl delete -f kubernetes/
```

## Best Practices

1. **Always use non-root users** in containers
2. **Set resource limits** to prevent resource exhaustion
3. **Use health checks** for liveness and readiness
4. **Implement rolling updates** with maxUnavailable=0
5. **Monitor pod restarts** and set restart budgets
6. **Use secrets management** (HashiCorp Vault, K8s Secrets)
7. **Enable network policies** for security
8. **Set image pull policies** correctly
9. **Use pod disruption budgets** for high availability
10. **Implement proper logging** with stdout/stderr

---

*Generated by AI ‚Ä¢ Updated February 2026*

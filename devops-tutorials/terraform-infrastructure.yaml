# Terraform Infrastructure as Code Templates

Production-ready Terraform modules for cloud infrastructure: VPC, Kubernetes clusters, load balancers, and more.

## What This Covers

- üèóÔ∏è **VPC & Networking** modules
- ‚ò∏Ô∏è **Kubernetes Cluster** setup (EKS/GKE/AKS)
- üîê **Load Balancers** & SSL termination
- üóÑÔ∏è **Database clusters**
- üîí **Secrets management**
- üìä **State backend** configuration

## File Structure

```
terraform/
‚îú‚îÄ‚îÄ main.tf
‚îú‚îÄ‚îÄ variables.tf
‚îú‚îÄ‚îÄ outputs.tf
‚îú‚îÄ‚îÄ modules/
‚îÇ   ‚îú‚îÄ‚îÄ vpc/
‚îÇ   ‚îú‚îÄ‚îÄ eks/
‚îÇ   ‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îú‚îÄ‚îÄ loadbalancer/
‚îÇ   ‚îî‚îÄ‚îÄ monitoring/
‚îî‚îÄ‚îÄ environments/
    ‚îú‚îÄ‚îÄ dev/
    ‚îú‚îÄ‚îÄ staging/
    ‚îî‚îÄ‚îÄ prod/
```

## Template 1: VPC Module

`terraform/modules/vpc/main.tf`:
```hcl
resource "aws_vpc" "main" {
  cidr_block           = var.cidr_block
  enable_dns_hostnames = true
  enable_dns_support   = true
  
  tags = {
    Name        = "${var.environment}-vpc"
    Environment = var.environment
    Terraform   = "true"
  }
}

resource "aws_subnet" "public" {
  count                   = length(var.public_subnet_cidrs)
  vpc_id                  = aws_vpc.main.id
  cidr_block              = var.public_subnet_cidrs[count.index]
  map_public_ip_on_launch = true
  
  availability_zone = var.availability_zones[count.index]
  
  tags = {
    Name        = "${var.environment}-public-${count.index + 1}"
    Type        = "public"
    Environment = var.environment
  }
}

resource "aws_subnet" "private" {
  count               = length(var.private_subnet_cidrs)
  vpc_id              = aws_vpc.main.id
  cidr_block          = var.private_subnet_cidrs[count.index]
  
  availability_zone = var.availability_zones[count.index]
  
  tags = {
    Name        = "${var.environment}-private-${count.index + 1}"
    Type        = "private"
    Environment = var.environment
  }
}

resource "aws_internet_gateway" "main" {
  vpc_id = aws_vpc.main.id
  
  tags = {
    Name        = "${var.environment}-igw"
    Environment = var.environment
  }
}

resource "aws_route_table" "public" {
  vpc_id = aws_vpc.main.id
  
  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.main.id
  }
  
  tags = {
    Name        = "${var.environment}-public-rt"
    Environment = var.environment
  }
}

resource "aws_route_table_association" "public" {
  count          = length(var.public_subnet_cidrs)
  subnet_id      = aws_subnet.public[count.index].id
  route_table_id = aws_route_table.public.id
}

resource "aws_nat_gateway" "main" {
  count         = length(var.public_subnet_cidrs)
  allocation_id = aws_eip.nat[count.index].id
  subnet_id     = aws_subnet.public[count.index].id
  
  tags = {
    Name        = "${var.environment}-nat-${count.index + 1}"
    Environment = var.environment
  }
}

resource "aws_eip" "nat" {
  count = length(var.public_subnet_cidrs)
  
  tags = {
    Name        = "${var.environment}-nat-${count.index + 1}"
    Environment = var.environment
  }
}

resource "aws_route_table" "private" {
  vpc_id = aws_vpc.main.id
  
  route {
    cidr_block     = "0.0.0.0/0"
    nat_gateway_id = aws_nat_gateway.main[count.index].id
  }
  
  tags = {
    Name        = "${var.environment}-private-rt-${count.index + 1}"
    Environment = var.environment
  }
}

resource "aws_route_table_association" "private" {
  count          = length(var.private_subnet_cidrs)
  subnet_id      = aws_subnet.private[count.index].id
  route_table_id = aws_route_table.private[count.index].id
}
```

`terraform/modules/vpc/variables.tf`:
```hcl
variable "region" {
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}

variable "environment" {
  description = "Environment name (dev, staging, prod)"
  type        = string
}

variable "vpc_name" {
  description = "VPC name"
  type        = string
  default     = "vpc"
}

variable "cidr_block" {
  description = "VPC CIDR block"
  type        = string
  default     = "10.0.0.0/16"
}

variable "availability_zones" {
  description = "List of availability zones"
  type        = list(string)
  default     = ["us-east-1a", "us-east-1b"]
}

variable "public_subnet_cidrs" {
  description = "List of public subnet CIDR blocks"
  type        = list(string)
  default     = ["10.0.1.0/24", "10.0.2.0/24"]
}

variable "private_subnet_cidrs" {
  description = "List of private subnet CIDR blocks"
  type        = list(string)
  default     = ["10.0.3.0/24", "10.0.4.0/24"]
}
```

`terraform/modules/vpc/outputs.tf`:
```hcl
output "vpc_id" {
  description = "ID of the VPC"
  value       = aws_vpc.main.id
}

output "vpc_cidr_block" {
  description = "CIDR block of the VPC"
  value       = aws_vpc.main.cidr_block
}

output "public_subnet_ids" {
  description = "List of public subnet IDs"
  value       = aws_subnet.public[*].id
}

output "private_subnet_ids" {
  description = "List of private subnet IDs"
  value       = aws_subnet.private[*].id
}

output "availability_zones" {
  description = "List of availability zones"
  value       = var.availability_zones
}
```

## Template 2: EKS Cluster Module

`terraform/modules/eks/main.tf`:
```hcl
module "eks" {
  source = "terraform-aws-modules/eks/aws"
  
  cluster_name    = "${var.environment}-cluster"
  cluster_version = var.kubernetes_version
  
  cluster_endpoint_access = "public"
  vpc_id                  = var.vpc_id
  
  cluster_addons = {
    coredns   = {}
    eks-pod-identity-agent = {}
    vpc-cni    = {}
    kube-proxy = {}
  }
  
  node_groups = [
    {
      name       = "worker-group"
      instance_types = ["m5.large", "m5a.large"]
      
      min_size     = 2
      max_size     = 10
      desired_size = 4
      
      labels = {
        role = "worker"
      }
      
  tags = {
    Environment = var.environment
    Node    = "worker"
  }
  
  bootstrap_extra_args = "--kubelet-extra-args '--max-pods=110'"
    }
  ]
  
  # EBS CSI driver
  ebs_csi_snapshot_controller = true
  
  # Security groups
  manage_node_security_group = true
  
  tags = {
    Terraform   = "true"
    Environment = var.environment
  }
}
```

`terraform/modules/eks/variables.tf`:
```hcl
variable "environment" {
  description = "Environment name"
  type        = string
}

variable "vpc_id" {
  description = "VPC ID for the cluster"
  type        = string
}

variable "private_subnet_ids" {
  description = "Private subnet IDs for worker nodes"
  type        = list(string)
}

variable "kubernetes_version" {
  description = "Kubernetes version"
  type        = string
  default     = "1.29"
}
```

`terraform/modules/eks/outputs.tf`:
```hcl
output "cluster_id" {
  description = "EKS cluster ID"
  value       = module.eks.cluster_id
}

output "cluster_endpoint" {
  description = "EKS cluster endpoint"
  value       = module.eks.cluster_endpoint
}

output "cluster_certificate_authority_data" {
  description = "EKS cluster certificate authority data"
  value       = module.eks.cluster_certificate_authority_data
  sensitive   = true
}
```

## Template 3: Load Balancer Module

`terraform/modules/loadbalancer/main.tf`:
```hcl
resource "aws_lb" "main" {
  name               = "${var.environment}-alb"
  internal           = var.internal
  load_balancer_type = "application"
  security_groups    = [aws_security_group.lb.id]
  subnets            = var.subnet_ids
  
  enable_deletion_protection = true
  
  enable_access_logs = {
    bucket  = aws_s3_bucket.lb_logs.bucket
    enabled = true
  }
  
  tags = {
    Name        = "${var.environment}-alb"
    Environment = var.environment
  }
}

resource "aws_lb_target_group" "main" {
  name     = "${var.environment}-tg"
  port     = var.port
  protocol = var.protocol
  vpc_id   = var.vpc_id
  
  health_check {
    path                = var.health_check_path
    healthy_threshold   = var.health_check_healthy_threshold
    unhealthy_threshold = 3
    interval            = 30
    timeout             = var.health_check_timeout
  }
  
  deregistration_delay = 30
  
  tags = {
    Name        = "${var.environment}-tg"
    Environment = var.environment
  }
}

resource "aws_lb_listener" "main" {
  load_balancer_arn = aws_lb.main.arn
  port              = 80
  protocol          = "HTTP"
  
  default_action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.main.arn
  }
}

resource "aws_security_group" "lb" {
  name        = "${var.environment}-lb-sg"
  description = "Security group for load balancer"
  vpc_id      = var.vpc_id
  
  ingress {
    description = "HTTP from VPC"
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  tags = {
    Name        = "${var.environment}-lb-sg"
    Environment = var.environment
  }
}

resource "aws_s3_bucket" "lb_logs" {
  bucket        = "${var.environment}-alb-logs-${random_string.bucket_suffix.result}"
  ForceDestroy  = true
}

resource "random_string" "bucket_suffix" {
  length  = 8
  special = false
}
```

`terraform/modules/loadbalancer/variables.tf`:
```hcl
variable "environment" {
  description = "Environment name"
  type        = string
}

variable "subnet_ids" {
  description = "Subnet IDs for the load balancer"
  type        = list(string)
}

variable "vpc_id" {
  description = "VPC ID"
  type        = string
}

variable "internal" {
  description = "Whether it's internal LB (default false)"
  type        = bool
  default     = false
}

variable "port" {
  description = "Target group port"
  type        = number
  default     = 3000
}

variable "protocol" {
  description = "Target group protocol"
  type        = string
  default     = "HTTP"
}

variable "health_check_path" {
  description = "Health check path"
  type        = string
  default     = "/health"
}

variable "health_check_timeout" {
  description = "Health check timeout"
  type        = number
  default     = 5
}

variable "health_check_healthy_threshold" {
  description = "Health check healthy threshold"
  type        = number
  default     = 2
}
```

`terraform/modules/loadbalancer/outputs.tf`:
```hcl
output "lb_arn" {
  description = "ARN of the load balancer"
  value       = aws_lb.main.arn
}

output "lb_dns_name" {
  description = "DNS name of the load balancer"
  value       = aws_lb.main.dns_name
}

output "target_group_arn" {
  description = "ARN of the target group"
  value       = aws_lb_target_group.main.arn
}
```

## Template 4: Database Module

`terraform/modules/database/main.tf`:
```hcl
resource "aws_db_subnet_group" "main" {
  name       = "${var.environment}-db-subnet-group"
  subnet_ids = var.subnet_ids
  
  tags = {
    Name        = "${var.environment}-db-subnet-group"
    Environment = var.environment
  }
}

resource "aws_security_group" "db" {
  name        = "${var.environment}-db-sg"
  description = "Security group for database"
  vpc_id      = var.vpc_id
  
  ingress {
    description     = "PostgreSQL from VPC"
    from_port       = 5432
    to_port         = 5432
    protocol        = "tcp"
    security_groups = var.db_access_security_groups
  }
  
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  tags = {
    Name        = "${var.environment}-db-sg"
    Environment = var.environment
  }
}

resource "aws_rds_cluster" "main" {
  cluster_identifier              = "${var.environment}-postgresql-cluster"
  engine                          = "aurora-postgresql"
  engine_mode                     = "provisioned"
  engine_version                  = "14.7"
  database_name                   = var.database_name
  port                            = 5432
  master_username                 = var.master_username
  master_password                 = var.master_password
  db_subnet_group_name            = aws_db_subnet_group.main.name
  vpc_security_group_ids          = [aws_security_group.db.id]
  storage_encrypted               = true
  deletion_protection             = var.deletion_protection
  backup_retention_period         = 7
  preferred_backup_window         = "02:00-03:00"
  enabled_cloudwatch_logs_exports = ["postgresql"]
  
  serverlessv2_scaling_configuration {
    min_capacity = var.min_capacity
    max_capacity = var.max_capacity
  }
  
  tags = {
    Environment = var.environment
    Database    = "postgresql"
  }
}

resource "aws_rds_cluster_instance" "main" {
  count              = var.instance_count
  identifier         = "${var.environment}-db-${count.index}"
  cluster_identifier = aws_rds_cluster.main.id
  instance_class     = var.instance_class
  engine             = aws_rds_cluster.main.engine
  engine_version     = aws_rds_cluster.main.engine_version
  
  publicly_accessible = false
  tags = {
    Name        = "${var.environment}-db-${count.index}"
    Environment = var.environment
  }
}

resource "aws_rds_cluster_parameter_group" "main" {
  family = aws_rds_cluster.main.engine_family
  
  parameter {
    name         = "log_connections"
    value        = "1"
    apply_method = "pending-reboot"
  }
  
  tags = {
    Environment = var.environment
  }
}
```

## Template 5: Secrets Management

`terraform/modules/secrets/main.tf`:
```hcl
resource "aws_secretsmanager_secret" "main" {
  name        = "${var.environment}/myapp/secrets"
  description = "Application secrets for ${var.environment}"
  recovery_window_in_days = var.recovery_window
}

resource "aws_secretsmanager_secret_version" "main" {
  secret_id     = aws_secretsmanager_secret.main.id
  secret_string = var.secret_string
  
  depends_on = [aws_secretsmanager_secret.main]
}

data "aws_secretsmanager_secret" "db" {
  name = "${var.environment}/database"
}

# For Kubernetes integration
resource "kubernetes_secret" "main" {
  metadata {
    name      = "myapp-secrets"
    namespace = "default"
  }
  
  data = {
    DB_URL  = base64encode(data.aws_secretsmanager_secret_version.main.secret_string)
    API_KEY = base64encode(var.api_key)
  }
}
```

## Using the Modules

`terraform/main.tf`:
```hcl
provider "aws" {
  region = var.region
  
  default_tags {
    tags = {
      Project   = "myapp"
      ManagedBy = "Terraform"
    }
  }
}

module "vpc" {
  source = "./modules/vpc"
  
  environment              = var.environment
  availability_zones       = var.availability_zones
  vpc_name                 = "myapp-vpc"
  cidr_block               = "10.0.0.0/16"
}

module "eks" {
  source = "./modules/eks"
  
  environment          = var.environment
  vpc_id               = module.vpc.vpc_id
  private_subnet_ids   = module.vpc.private_subnet_ids
  kubernetes_version   = "1.29"
}

module "database" {
  source = "./modules/database"
  
  environment                    = var.environment
  vpc_id                         = module.vpc.vpc_id
  subnet_ids                     = module.vpc.private_subnet_ids
  master_username                = var.database_user
  master_password                = var.database_password
  database_name                  = var.database_name
  instance_class                 = "db.serverless"
  min_capacity                   = 0.5
  max_capacity                   = 128
}
```

## Terraform Best Practices

1. **Use state locking** (S3 + DynamoDB)
2. **Enable encryption** for S3 buckets and secrets
3. **Use version control** for all Terraform files
4. **Implement CI/CD** for Terraform plans/apply
5. **Tag all resources** for cost tracking
6. **Use workspaces** for environments
7. **Separate state files** per environment
8. **Enable plan review** in CI/CD
9. **Use output validation** where possible
10. **Regular state file maintenance**

---

*Generated by AI ‚Ä¢ Updated February 2026*
